{"ast":null,"code":"'use strict';\n\nvar high = require('highlight.js/lib/highlight.js');\nvar fault = require('fault');\n\n/* The lowlight interface, which has to be compatible\n * with highlight.js, as this object is passed to\n * highlight.js syntaxes. */\n\nfunction High() {}\nHigh.prototype = high;\n\n/* Expose. */\nvar low = new High(); // Ha!\n\nmodule.exports = low;\nlow.highlight = highlight;\nlow.highlightAuto = autoHighlight;\nlow.registerLanguage = registerLanguage;\nlow.getLanguage = getLanguage;\nvar inherit = high.inherit;\nvar own = {}.hasOwnProperty;\nvar concat = [].concat;\nvar defaultPrefix = 'hljs-';\nvar keyInsensitive = 'case_insensitive';\nvar keyCachedVariants = 'cached_variants';\nvar space = ' ';\nvar pipe = '|';\nvar T_ELEMENT = 'element';\nvar T_TEXT = 'text';\nvar T_SPAN = 'span';\n\n/* Maps of syntaxes. */\nvar languageNames = [];\nvar languages = {};\nvar aliases = {};\n\n/* Highlighting with language detection.  Accepts a string\n * with the code to highlight.  Returns an object with the\n * following properties:\n *\n * - language (detected language)\n * - relevance (int)\n * - value (a HAST tree with highlighting markup)\n * - secondBest (object with the same structure for\n *   second-best heuristically detected language, may\n *   be absent) */\nfunction autoHighlight(value, options) {\n  var settings = options || {};\n  var subset = settings.subset || languageNames;\n  var prefix = settings.prefix;\n  var length = subset.length;\n  var index = -1;\n  var result;\n  var secondBest;\n  var current;\n  var name;\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix;\n  }\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value);\n  }\n  secondBest = normalize({});\n  result = normalize({});\n  while (++index < length) {\n    name = subset[index];\n    if (!getLanguage(name)) {\n      continue;\n    }\n    current = normalize(coreHighlight(name, value, false, prefix));\n    current.language = name;\n    if (current.relevance > secondBest.relevance) {\n      secondBest = current;\n    }\n    if (current.relevance > result.relevance) {\n      secondBest = result;\n      result = current;\n    }\n  }\n  if (secondBest.language) {\n    result.secondBest = secondBest;\n  }\n  return result;\n}\n\n/* Highlighting `value` in the language `language`. */\nfunction highlight(language, value, options) {\n  var settings = options || {};\n  var prefix = settings.prefix;\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix;\n  }\n  return normalize(coreHighlight(language, value, true, prefix));\n}\n\n/* Register a language. */\nfunction registerLanguage(name, syntax) {\n  var lang = syntax(low);\n  var values = lang.aliases;\n  var length = values && values.length;\n  var index = -1;\n  languages[name] = lang;\n  languageNames.push(name);\n  while (++index < length) {\n    aliases[values[index]] = name;\n  }\n}\n\n/* Core highlighting function.  Accepts a language name, or\n * an alias, and a string with the code to highlight.\n * Returns an object with the following properties: */\nfunction coreHighlight(name, value, ignore, prefix, continuation) {\n  var continuations = {};\n  var stack = [];\n  var modeBuffer = '';\n  var relevance = 0;\n  var language;\n  var top;\n  var current;\n  var currentChildren;\n  var offset;\n  var count;\n  var match;\n  var children;\n  if (typeof name !== 'string') {\n    throw fault('Expected `string` for name, got `%s`', name);\n  }\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value);\n  }\n  language = getLanguage(name);\n  top = continuation || language;\n  children = [];\n  current = top;\n  currentChildren = children;\n  if (!language) {\n    throw fault('Unknown language: `%s` is not registered', name);\n  }\n  compileLanguage(language);\n  try {\n    top.terminators.lastIndex = 0;\n    offset = 0;\n    match = top.terminators.exec(value);\n    while (match) {\n      count = processLexeme(value.substring(offset, match.index), match[0]);\n      offset = match.index + count;\n      top.terminators.lastIndex = offset;\n      match = top.terminators.exec(value);\n    }\n    processLexeme(value.substr(offset));\n    current = top;\n    while (current.parent) {\n      if (current.className) {\n        pop();\n      }\n      current = current.parent;\n    }\n    return {\n      relevance: relevance,\n      value: currentChildren,\n      language: name,\n      top: top\n    };\n  } catch (err) {\n    /* istanbul ignore if - Catch-all  */\n    if (err.message.indexOf('Illegal') === -1) {\n      throw err;\n    }\n    return {\n      relevance: 0,\n      value: addText(value, [])\n    };\n  }\n\n  /* Process a lexeme.  Returns next position. */\n  function processLexeme(buffer, lexeme) {\n    var newMode;\n    var endMode;\n    var origin;\n    modeBuffer += buffer;\n    if (lexeme === undefined) {\n      addSiblings(processBuffer(), currentChildren);\n      return 0;\n    }\n    newMode = subMode(lexeme, top);\n    if (newMode) {\n      addSiblings(processBuffer(), currentChildren);\n      startNewMode(newMode, lexeme);\n      return newMode.returnBegin ? 0 : lexeme.length;\n    }\n    endMode = endOfMode(top, lexeme);\n    if (endMode) {\n      origin = top;\n      if (!(origin.returnEnd || origin.excludeEnd)) {\n        modeBuffer += lexeme;\n      }\n      addSiblings(processBuffer(), currentChildren);\n\n      /* Close open modes. */\n      do {\n        if (top.className) {\n          pop();\n        }\n        relevance += top.relevance;\n        top = top.parent;\n      } while (top !== endMode.parent);\n      if (origin.excludeEnd) {\n        addText(lexeme, currentChildren);\n      }\n      modeBuffer = '';\n      if (endMode.starts) {\n        startNewMode(endMode.starts, '');\n      }\n      return origin.returnEnd ? 0 : lexeme.length;\n    }\n    if (isIllegal(lexeme, top)) {\n      throw fault('Illegal lexeme \"%s\" for mode \"%s\"', lexeme, top.className || '<unnamed>');\n    }\n\n    /* Parser should not reach this point as all\n     * types of lexemes should be caught earlier,\n     * but if it does due to some bug make sure it\n     * advances at least one character forward to\n     * prevent infinite looping. */\n    modeBuffer += lexeme;\n    return lexeme.length || /* istanbul ignore next */1;\n  }\n\n  /* Start a new mode with a `lexeme` to process. */\n  function startNewMode(mode, lexeme) {\n    var node;\n    if (mode.className) {\n      node = build(mode.className, []);\n    }\n    if (mode.returnBegin) {\n      modeBuffer = '';\n    } else if (mode.excludeBegin) {\n      addText(lexeme, currentChildren);\n      modeBuffer = '';\n    } else {\n      modeBuffer = lexeme;\n    }\n\n    /* Enter a new mode. */\n    if (node) {\n      currentChildren.push(node);\n      stack.push(currentChildren);\n      currentChildren = node.children;\n    }\n    top = Object.create(mode, {\n      parent: {\n        value: top\n      }\n    });\n  }\n\n  /* Process the buffer. */\n  function processBuffer() {\n    var result = top.subLanguage ? processSubLanguage() : processKeywords();\n    modeBuffer = '';\n    return result;\n  }\n\n  /* Process a sublanguage (returns a list of nodes). */\n  function processSubLanguage() {\n    var explicit = typeof top.subLanguage === 'string';\n    var subvalue;\n\n    /* istanbul ignore if - support non-loaded sublanguages */\n    if (explicit && !languages[top.subLanguage]) {\n      return addText(modeBuffer, []);\n    }\n    if (explicit) {\n      subvalue = coreHighlight(top.subLanguage, modeBuffer, true, prefix, continuations[top.subLanguage]);\n    } else {\n      subvalue = autoHighlight(modeBuffer, {\n        subset: top.subLanguage.length ? top.subLanguage : undefined,\n        prefix: prefix\n      });\n    }\n\n    /* Counting embedded language score towards the\n     * host language may be disabled with zeroing the\n     * containing mode relevance.  Usecase in point is\n     * Markdown that allows XML everywhere and makes\n     * every XML snippet to have a much larger Markdown\n     * score. */\n    if (top.relevance > 0) {\n      relevance += subvalue.relevance;\n    }\n    if (explicit) {\n      continuations[top.subLanguage] = subvalue.top;\n    }\n    return [build(subvalue.language, subvalue.value, true)];\n  }\n\n  /* Process keywords. Returns nodes. */\n  function processKeywords() {\n    var nodes = [];\n    var lastIndex;\n    var keyword;\n    var node;\n    var submatch;\n    if (!top.keywords) {\n      return addText(modeBuffer, nodes);\n    }\n    lastIndex = 0;\n    top.lexemesRe.lastIndex = 0;\n    keyword = top.lexemesRe.exec(modeBuffer);\n    while (keyword) {\n      addText(modeBuffer.substring(lastIndex, keyword.index), nodes);\n      submatch = keywordMatch(top, keyword);\n      if (submatch) {\n        relevance += submatch[1];\n        node = build(submatch[0], []);\n        nodes.push(node);\n        addText(keyword[0], node.children);\n      } else {\n        addText(keyword[0], nodes);\n      }\n      lastIndex = top.lexemesRe.lastIndex;\n      keyword = top.lexemesRe.exec(modeBuffer);\n    }\n    addText(modeBuffer.substr(lastIndex), nodes);\n    return nodes;\n  }\n\n  /* Add siblings. */\n  function addSiblings(siblings, nodes) {\n    var length = siblings.length;\n    var index = -1;\n    var sibling;\n    while (++index < length) {\n      sibling = siblings[index];\n      if (sibling.type === T_TEXT) {\n        addText(sibling.value, nodes);\n      } else {\n        nodes.push(sibling);\n      }\n    }\n  }\n\n  /* Add a text. */\n  function addText(value, nodes) {\n    var tail;\n    if (value) {\n      tail = nodes[nodes.length - 1];\n      if (tail && tail.type === T_TEXT) {\n        tail.value += value;\n      } else {\n        nodes.push(buildText(value));\n      }\n    }\n    return nodes;\n  }\n\n  /* Build a text. */\n  function buildText(value) {\n    return {\n      type: T_TEXT,\n      value: value\n    };\n  }\n\n  /* Build a span. */\n  function build(name, contents, noPrefix) {\n    return {\n      type: T_ELEMENT,\n      tagName: T_SPAN,\n      properties: {\n        className: [(noPrefix ? '' : prefix) + name]\n      },\n      children: contents\n    };\n  }\n\n  /* Check if the first word in `keywords` is a keyword. */\n  function keywordMatch(mode, keywords) {\n    var keyword = keywords[0];\n    if (language[keyInsensitive]) {\n      keyword = keyword.toLowerCase();\n    }\n    return own.call(mode.keywords, keyword) && mode.keywords[keyword];\n  }\n\n  /* Check if `lexeme` is illegal according to `mode`. */\n  function isIllegal(lexeme, mode) {\n    return !ignore && test(mode.illegalRe, lexeme);\n  }\n\n  /* Check if `lexeme` ends `mode`. */\n  function endOfMode(mode, lexeme) {\n    if (test(mode.endRe, lexeme)) {\n      while (mode.endsParent && mode.parent) {\n        mode = mode.parent;\n      }\n      return mode;\n    }\n    if (mode.endsWithParent) {\n      return endOfMode(mode.parent, lexeme);\n    }\n  }\n\n  /* Check a sub-mode. */\n  function subMode(lexeme, mode) {\n    var values = mode.contains;\n    var length = values.length;\n    var index = -1;\n    while (++index < length) {\n      if (test(values[index].beginRe, lexeme)) {\n        return values[index];\n      }\n    }\n  }\n\n  /* Exit the current context. */\n  function pop() {\n    /* istanbul ignore next - removed in hljs 9.3 */\n    currentChildren = stack.pop() || children;\n  }\n}\nfunction expandMode(mode) {\n  var length;\n  var index;\n  var variants;\n  var result;\n  if (mode.variants && !mode[keyCachedVariants]) {\n    variants = mode.variants;\n    length = variants.length;\n    index = -1;\n    result = [];\n    while (++index < length) {\n      result[index] = inherit(mode, {\n        variants: null\n      }, variants[index]);\n    }\n    mode[keyCachedVariants] = result;\n  }\n  return mode[keyCachedVariants] || (mode.endsWithParent ? [inherit(mode)] : [mode]);\n}\n\n/* Compile a language. */\nfunction compileLanguage(language) {\n  compileMode(language);\n\n  /* Compile a language mode, optionally with a parent. */\n  function compileMode(mode, parent) {\n    var compiledKeywords = {};\n    var terminators;\n    if (mode.compiled) {\n      return;\n    }\n    mode.compiled = true;\n    mode.keywords = mode.keywords || mode.beginKeywords;\n    if (mode.keywords) {\n      if (typeof mode.keywords === 'string') {\n        flatten('keyword', mode.keywords);\n      } else {\n        Object.keys(mode.keywords).forEach(function (className) {\n          flatten(className, mode.keywords[className]);\n        });\n      }\n      mode.keywords = compiledKeywords;\n    }\n    mode.lexemesRe = langRe(mode.lexemes || /\\w+/, true);\n    if (parent) {\n      if (mode.beginKeywords) {\n        mode.begin = '\\\\b(' + mode.beginKeywords.split(space).join(pipe) + ')\\\\b';\n      }\n      if (!mode.begin) {\n        mode.begin = /\\B|\\b/;\n      }\n      mode.beginRe = langRe(mode.begin);\n      if (!mode.end && !mode.endsWithParent) {\n        mode.end = /\\B|\\b/;\n      }\n      if (mode.end) {\n        mode.endRe = langRe(mode.end);\n      }\n      mode.terminatorEnd = source(mode.end) || '';\n      if (mode.endsWithParent && parent.terminatorEnd) {\n        mode.terminatorEnd += (mode.end ? pipe : '') + parent.terminatorEnd;\n      }\n    }\n    if (mode.illegal) {\n      mode.illegalRe = langRe(mode.illegal);\n    }\n    if (mode.relevance === undefined) {\n      mode.relevance = 1;\n    }\n    if (!mode.contains) {\n      mode.contains = [];\n    }\n    mode.contains = concat.apply([], mode.contains.map(function (c) {\n      return expandMode(c === 'self' ? mode : c);\n    }));\n    mode.contains.forEach(function (c) {\n      compileMode(c, mode);\n    });\n    if (mode.starts) {\n      compileMode(mode.starts, parent);\n    }\n    terminators = mode.contains.map(map).concat([mode.terminatorEnd, mode.illegal]).map(source).filter(Boolean);\n    mode.terminators = terminators.length ? langRe(terminators.join(pipe), true) : {\n      exec: execNoop\n    };\n    function map(c) {\n      return c.beginKeywords ? '\\\\.?(' + c.begin + ')\\\\.?' : c.begin;\n    }\n\n    /* Flatten a classname. */\n    function flatten(className, value) {\n      var pairs;\n      var pair;\n      var index;\n      var length;\n      if (language[keyInsensitive]) {\n        value = value.toLowerCase();\n      }\n      pairs = value.split(space);\n      length = pairs.length;\n      index = -1;\n      while (++index < length) {\n        pair = pairs[index].split(pipe);\n        compiledKeywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1];\n      }\n    }\n  }\n\n  /* Create a regex for `value`. */\n  function langRe(value, global) {\n    return new RegExp(source(value), 'm' + (language[keyInsensitive] ? 'i' : '') + (global ? 'g' : ''));\n  }\n\n  /* Get the source of an expression or string. */\n  function source(re) {\n    return re && re.source || re;\n  }\n}\n\n/* Normalize a syntax result. */\nfunction normalize(result) {\n  return {\n    relevance: result.relevance || 0,\n    language: result.language || null,\n    value: result.value || []\n  };\n}\n\n/* Check if `expression` matches `lexeme`. */\nfunction test(expression, lexeme) {\n  var match = expression && expression.exec(lexeme);\n  return match && match.index === 0;\n}\n\n/* No-op exec. */\nfunction execNoop() {\n  return null;\n}\n\n/* Get a language by `name`. */\nfunction getLanguage(name) {\n  name = name.toLowerCase();\n  return languages[name] || languages[aliases[name]];\n}","map":{"version":3,"names":["high","require","fault","High","prototype","low","module","exports","highlight","highlightAuto","autoHighlight","registerLanguage","getLanguage","inherit","own","hasOwnProperty","concat","defaultPrefix","keyInsensitive","keyCachedVariants","space","pipe","T_ELEMENT","T_TEXT","T_SPAN","languageNames","languages","aliases","value","options","settings","subset","prefix","length","index","result","secondBest","current","name","undefined","normalize","coreHighlight","language","relevance","syntax","lang","values","push","ignore","continuation","continuations","stack","modeBuffer","top","currentChildren","offset","count","match","children","compileLanguage","terminators","lastIndex","exec","processLexeme","substring","substr","parent","className","pop","err","message","indexOf","addText","buffer","lexeme","newMode","endMode","origin","addSiblings","processBuffer","subMode","startNewMode","returnBegin","endOfMode","returnEnd","excludeEnd","starts","isIllegal","mode","node","build","excludeBegin","Object","create","subLanguage","processSubLanguage","processKeywords","explicit","subvalue","nodes","keyword","submatch","keywords","lexemesRe","keywordMatch","siblings","sibling","type","tail","buildText","contents","noPrefix","tagName","properties","toLowerCase","call","test","illegalRe","endRe","endsParent","endsWithParent","contains","beginRe","expandMode","variants","compileMode","compiledKeywords","compiled","beginKeywords","flatten","keys","forEach","langRe","lexemes","begin","split","join","end","terminatorEnd","source","illegal","apply","map","c","filter","Boolean","execNoop","pairs","pair","Number","global","RegExp","re","expression"],"sources":["/Users/azminds/Documents/five-g/frontend/node_modules/terminal-in-react-pseudo-file-system-plugin/node_modules/lowlight/lib/core.js"],"sourcesContent":["'use strict'\n\nvar high = require('highlight.js/lib/highlight.js')\nvar fault = require('fault')\n\n/* The lowlight interface, which has to be compatible\n * with highlight.js, as this object is passed to\n * highlight.js syntaxes. */\n\nfunction High() {}\n\nHigh.prototype = high\n\n/* Expose. */\nvar low = new High() // Ha!\n\nmodule.exports = low\n\nlow.highlight = highlight\nlow.highlightAuto = autoHighlight\nlow.registerLanguage = registerLanguage\nlow.getLanguage = getLanguage\n\nvar inherit = high.inherit\nvar own = {}.hasOwnProperty\nvar concat = [].concat\n\nvar defaultPrefix = 'hljs-'\nvar keyInsensitive = 'case_insensitive'\nvar keyCachedVariants = 'cached_variants'\nvar space = ' '\nvar pipe = '|'\n\nvar T_ELEMENT = 'element'\nvar T_TEXT = 'text'\nvar T_SPAN = 'span'\n\n/* Maps of syntaxes. */\nvar languageNames = []\nvar languages = {}\nvar aliases = {}\n\n/* Highlighting with language detection.  Accepts a string\n * with the code to highlight.  Returns an object with the\n * following properties:\n *\n * - language (detected language)\n * - relevance (int)\n * - value (a HAST tree with highlighting markup)\n * - secondBest (object with the same structure for\n *   second-best heuristically detected language, may\n *   be absent) */\nfunction autoHighlight(value, options) {\n  var settings = options || {}\n  var subset = settings.subset || languageNames\n  var prefix = settings.prefix\n  var length = subset.length\n  var index = -1\n  var result\n  var secondBest\n  var current\n  var name\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  secondBest = normalize({})\n  result = normalize({})\n\n  while (++index < length) {\n    name = subset[index]\n\n    if (!getLanguage(name)) {\n      continue\n    }\n\n    current = normalize(coreHighlight(name, value, false, prefix))\n\n    current.language = name\n\n    if (current.relevance > secondBest.relevance) {\n      secondBest = current\n    }\n\n    if (current.relevance > result.relevance) {\n      secondBest = result\n      result = current\n    }\n  }\n\n  if (secondBest.language) {\n    result.secondBest = secondBest\n  }\n\n  return result\n}\n\n/* Highlighting `value` in the language `language`. */\nfunction highlight(language, value, options) {\n  var settings = options || {}\n  var prefix = settings.prefix\n\n  if (prefix === null || prefix === undefined) {\n    prefix = defaultPrefix\n  }\n\n  return normalize(coreHighlight(language, value, true, prefix))\n}\n\n/* Register a language. */\nfunction registerLanguage(name, syntax) {\n  var lang = syntax(low)\n  var values = lang.aliases\n  var length = values && values.length\n  var index = -1\n\n  languages[name] = lang\n\n  languageNames.push(name)\n\n  while (++index < length) {\n    aliases[values[index]] = name\n  }\n}\n\n/* Core highlighting function.  Accepts a language name, or\n * an alias, and a string with the code to highlight.\n * Returns an object with the following properties: */\nfunction coreHighlight(name, value, ignore, prefix, continuation) {\n  var continuations = {}\n  var stack = []\n  var modeBuffer = ''\n  var relevance = 0\n  var language\n  var top\n  var current\n  var currentChildren\n  var offset\n  var count\n  var match\n  var children\n\n  if (typeof name !== 'string') {\n    throw fault('Expected `string` for name, got `%s`', name)\n  }\n\n  if (typeof value !== 'string') {\n    throw fault('Expected `string` for value, got `%s`', value)\n  }\n\n  language = getLanguage(name)\n  top = continuation || language\n  children = []\n\n  current = top\n  currentChildren = children\n\n  if (!language) {\n    throw fault('Unknown language: `%s` is not registered', name)\n  }\n\n  compileLanguage(language)\n\n  try {\n    top.terminators.lastIndex = 0\n    offset = 0\n    match = top.terminators.exec(value)\n\n    while (match) {\n      count = processLexeme(value.substring(offset, match.index), match[0])\n      offset = match.index + count\n      top.terminators.lastIndex = offset\n      match = top.terminators.exec(value)\n    }\n\n    processLexeme(value.substr(offset))\n    current = top\n\n    while (current.parent) {\n      if (current.className) {\n        pop()\n      }\n\n      current = current.parent\n    }\n\n    return {\n      relevance: relevance,\n      value: currentChildren,\n      language: name,\n      top: top\n    }\n  } catch (err) {\n    /* istanbul ignore if - Catch-all  */\n    if (err.message.indexOf('Illegal') === -1) {\n      throw err\n    }\n\n    return {relevance: 0, value: addText(value, [])}\n  }\n\n  /* Process a lexeme.  Returns next position. */\n  function processLexeme(buffer, lexeme) {\n    var newMode\n    var endMode\n    var origin\n\n    modeBuffer += buffer\n\n    if (lexeme === undefined) {\n      addSiblings(processBuffer(), currentChildren)\n\n      return 0\n    }\n\n    newMode = subMode(lexeme, top)\n\n    if (newMode) {\n      addSiblings(processBuffer(), currentChildren)\n\n      startNewMode(newMode, lexeme)\n\n      return newMode.returnBegin ? 0 : lexeme.length\n    }\n\n    endMode = endOfMode(top, lexeme)\n\n    if (endMode) {\n      origin = top\n\n      if (!(origin.returnEnd || origin.excludeEnd)) {\n        modeBuffer += lexeme\n      }\n\n      addSiblings(processBuffer(), currentChildren)\n\n      /* Close open modes. */\n      do {\n        if (top.className) {\n          pop()\n        }\n\n        relevance += top.relevance\n        top = top.parent\n      } while (top !== endMode.parent)\n\n      if (origin.excludeEnd) {\n        addText(lexeme, currentChildren)\n      }\n\n      modeBuffer = ''\n\n      if (endMode.starts) {\n        startNewMode(endMode.starts, '')\n      }\n\n      return origin.returnEnd ? 0 : lexeme.length\n    }\n\n    if (isIllegal(lexeme, top)) {\n      throw fault(\n        'Illegal lexeme \"%s\" for mode \"%s\"',\n        lexeme,\n        top.className || '<unnamed>'\n      )\n    }\n\n    /* Parser should not reach this point as all\n     * types of lexemes should be caught earlier,\n     * but if it does due to some bug make sure it\n     * advances at least one character forward to\n     * prevent infinite looping. */\n    modeBuffer += lexeme\n\n    return lexeme.length || /* istanbul ignore next */ 1\n  }\n\n  /* Start a new mode with a `lexeme` to process. */\n  function startNewMode(mode, lexeme) {\n    var node\n\n    if (mode.className) {\n      node = build(mode.className, [])\n    }\n\n    if (mode.returnBegin) {\n      modeBuffer = ''\n    } else if (mode.excludeBegin) {\n      addText(lexeme, currentChildren)\n\n      modeBuffer = ''\n    } else {\n      modeBuffer = lexeme\n    }\n\n    /* Enter a new mode. */\n    if (node) {\n      currentChildren.push(node)\n      stack.push(currentChildren)\n      currentChildren = node.children\n    }\n\n    top = Object.create(mode, {parent: {value: top}})\n  }\n\n  /* Process the buffer. */\n  function processBuffer() {\n    var result = top.subLanguage ? processSubLanguage() : processKeywords()\n    modeBuffer = ''\n    return result\n  }\n\n  /* Process a sublanguage (returns a list of nodes). */\n  function processSubLanguage() {\n    var explicit = typeof top.subLanguage === 'string'\n    var subvalue\n\n    /* istanbul ignore if - support non-loaded sublanguages */\n    if (explicit && !languages[top.subLanguage]) {\n      return addText(modeBuffer, [])\n    }\n\n    if (explicit) {\n      subvalue = coreHighlight(\n        top.subLanguage,\n        modeBuffer,\n        true,\n        prefix,\n        continuations[top.subLanguage]\n      )\n    } else {\n      subvalue = autoHighlight(modeBuffer, {\n        subset: top.subLanguage.length ? top.subLanguage : undefined,\n        prefix: prefix\n      })\n    }\n\n    /* Counting embedded language score towards the\n     * host language may be disabled with zeroing the\n     * containing mode relevance.  Usecase in point is\n     * Markdown that allows XML everywhere and makes\n     * every XML snippet to have a much larger Markdown\n     * score. */\n    if (top.relevance > 0) {\n      relevance += subvalue.relevance\n    }\n\n    if (explicit) {\n      continuations[top.subLanguage] = subvalue.top\n    }\n\n    return [build(subvalue.language, subvalue.value, true)]\n  }\n\n  /* Process keywords. Returns nodes. */\n  function processKeywords() {\n    var nodes = []\n    var lastIndex\n    var keyword\n    var node\n    var submatch\n\n    if (!top.keywords) {\n      return addText(modeBuffer, nodes)\n    }\n\n    lastIndex = 0\n\n    top.lexemesRe.lastIndex = 0\n\n    keyword = top.lexemesRe.exec(modeBuffer)\n\n    while (keyword) {\n      addText(modeBuffer.substring(lastIndex, keyword.index), nodes)\n\n      submatch = keywordMatch(top, keyword)\n\n      if (submatch) {\n        relevance += submatch[1]\n\n        node = build(submatch[0], [])\n\n        nodes.push(node)\n\n        addText(keyword[0], node.children)\n      } else {\n        addText(keyword[0], nodes)\n      }\n\n      lastIndex = top.lexemesRe.lastIndex\n      keyword = top.lexemesRe.exec(modeBuffer)\n    }\n\n    addText(modeBuffer.substr(lastIndex), nodes)\n\n    return nodes\n  }\n\n  /* Add siblings. */\n  function addSiblings(siblings, nodes) {\n    var length = siblings.length\n    var index = -1\n    var sibling\n\n    while (++index < length) {\n      sibling = siblings[index]\n\n      if (sibling.type === T_TEXT) {\n        addText(sibling.value, nodes)\n      } else {\n        nodes.push(sibling)\n      }\n    }\n  }\n\n  /* Add a text. */\n  function addText(value, nodes) {\n    var tail\n\n    if (value) {\n      tail = nodes[nodes.length - 1]\n\n      if (tail && tail.type === T_TEXT) {\n        tail.value += value\n      } else {\n        nodes.push(buildText(value))\n      }\n    }\n\n    return nodes\n  }\n\n  /* Build a text. */\n  function buildText(value) {\n    return {type: T_TEXT, value: value}\n  }\n\n  /* Build a span. */\n  function build(name, contents, noPrefix) {\n    return {\n      type: T_ELEMENT,\n      tagName: T_SPAN,\n      properties: {\n        className: [(noPrefix ? '' : prefix) + name]\n      },\n      children: contents\n    }\n  }\n\n  /* Check if the first word in `keywords` is a keyword. */\n  function keywordMatch(mode, keywords) {\n    var keyword = keywords[0]\n\n    if (language[keyInsensitive]) {\n      keyword = keyword.toLowerCase()\n    }\n\n    return own.call(mode.keywords, keyword) && mode.keywords[keyword]\n  }\n\n  /* Check if `lexeme` is illegal according to `mode`. */\n  function isIllegal(lexeme, mode) {\n    return !ignore && test(mode.illegalRe, lexeme)\n  }\n\n  /* Check if `lexeme` ends `mode`. */\n  function endOfMode(mode, lexeme) {\n    if (test(mode.endRe, lexeme)) {\n      while (mode.endsParent && mode.parent) {\n        mode = mode.parent\n      }\n\n      return mode\n    }\n\n    if (mode.endsWithParent) {\n      return endOfMode(mode.parent, lexeme)\n    }\n  }\n\n  /* Check a sub-mode. */\n  function subMode(lexeme, mode) {\n    var values = mode.contains\n    var length = values.length\n    var index = -1\n\n    while (++index < length) {\n      if (test(values[index].beginRe, lexeme)) {\n        return values[index]\n      }\n    }\n  }\n\n  /* Exit the current context. */\n  function pop() {\n    /* istanbul ignore next - removed in hljs 9.3 */\n    currentChildren = stack.pop() || children\n  }\n}\n\nfunction expandMode(mode) {\n  var length\n  var index\n  var variants\n  var result\n\n  if (mode.variants && !mode[keyCachedVariants]) {\n    variants = mode.variants\n    length = variants.length\n    index = -1\n    result = []\n\n    while (++index < length) {\n      result[index] = inherit(mode, {variants: null}, variants[index])\n    }\n\n    mode[keyCachedVariants] = result\n  }\n\n  return (\n    mode[keyCachedVariants] || (mode.endsWithParent ? [inherit(mode)] : [mode])\n  )\n}\n\n/* Compile a language. */\nfunction compileLanguage(language) {\n  compileMode(language)\n\n  /* Compile a language mode, optionally with a parent. */\n  function compileMode(mode, parent) {\n    var compiledKeywords = {}\n    var terminators\n\n    if (mode.compiled) {\n      return\n    }\n\n    mode.compiled = true\n\n    mode.keywords = mode.keywords || mode.beginKeywords\n\n    if (mode.keywords) {\n      if (typeof mode.keywords === 'string') {\n        flatten('keyword', mode.keywords)\n      } else {\n        Object.keys(mode.keywords).forEach(function(className) {\n          flatten(className, mode.keywords[className])\n        })\n      }\n\n      mode.keywords = compiledKeywords\n    }\n\n    mode.lexemesRe = langRe(mode.lexemes || /\\w+/, true)\n\n    if (parent) {\n      if (mode.beginKeywords) {\n        mode.begin =\n          '\\\\b(' + mode.beginKeywords.split(space).join(pipe) + ')\\\\b'\n      }\n\n      if (!mode.begin) {\n        mode.begin = /\\B|\\b/\n      }\n\n      mode.beginRe = langRe(mode.begin)\n\n      if (!mode.end && !mode.endsWithParent) {\n        mode.end = /\\B|\\b/\n      }\n\n      if (mode.end) {\n        mode.endRe = langRe(mode.end)\n      }\n\n      mode.terminatorEnd = source(mode.end) || ''\n\n      if (mode.endsWithParent && parent.terminatorEnd) {\n        mode.terminatorEnd += (mode.end ? pipe : '') + parent.terminatorEnd\n      }\n    }\n\n    if (mode.illegal) {\n      mode.illegalRe = langRe(mode.illegal)\n    }\n\n    if (mode.relevance === undefined) {\n      mode.relevance = 1\n    }\n\n    if (!mode.contains) {\n      mode.contains = []\n    }\n\n    mode.contains = concat.apply(\n      [],\n      mode.contains.map(function(c) {\n        return expandMode(c === 'self' ? mode : c)\n      })\n    )\n\n    mode.contains.forEach(function(c) {\n      compileMode(c, mode)\n    })\n\n    if (mode.starts) {\n      compileMode(mode.starts, parent)\n    }\n\n    terminators = mode.contains\n      .map(map)\n      .concat([mode.terminatorEnd, mode.illegal])\n      .map(source)\n      .filter(Boolean)\n\n    mode.terminators = terminators.length\n      ? langRe(terminators.join(pipe), true)\n      : {exec: execNoop}\n\n    function map(c) {\n      return c.beginKeywords ? '\\\\.?(' + c.begin + ')\\\\.?' : c.begin\n    }\n\n    /* Flatten a classname. */\n    function flatten(className, value) {\n      var pairs\n      var pair\n      var index\n      var length\n\n      if (language[keyInsensitive]) {\n        value = value.toLowerCase()\n      }\n\n      pairs = value.split(space)\n      length = pairs.length\n      index = -1\n\n      while (++index < length) {\n        pair = pairs[index].split(pipe)\n\n        compiledKeywords[pair[0]] = [className, pair[1] ? Number(pair[1]) : 1]\n      }\n    }\n  }\n\n  /* Create a regex for `value`. */\n  function langRe(value, global) {\n    return new RegExp(\n      source(value),\n      'm' + (language[keyInsensitive] ? 'i' : '') + (global ? 'g' : '')\n    )\n  }\n\n  /* Get the source of an expression or string. */\n  function source(re) {\n    return (re && re.source) || re\n  }\n}\n\n/* Normalize a syntax result. */\nfunction normalize(result) {\n  return {\n    relevance: result.relevance || 0,\n    language: result.language || null,\n    value: result.value || []\n  }\n}\n\n/* Check if `expression` matches `lexeme`. */\nfunction test(expression, lexeme) {\n  var match = expression && expression.exec(lexeme)\n  return match && match.index === 0\n}\n\n/* No-op exec. */\nfunction execNoop() {\n  return null\n}\n\n/* Get a language by `name`. */\nfunction getLanguage(name) {\n  name = name.toLowerCase()\n\n  return languages[name] || languages[aliases[name]]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}