{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { decorate, internalDeprecation } from './private/utils';\nfunction toObject(cache, value) {\n  if (value === Object(value)) {\n    return value;\n  }\n  return cache[value] || (cache[value] = {});\n}\nfunction applyAndCache(context, fn, args, cache, signature) {\n  var ret = fn.apply(context, args);\n  cache[signature] = ret;\n  return ret;\n}\nfunction metaForDescriptor(descriptor) {\n  var fn = void 0,\n    wrapKey = void 0;\n\n  // This is ugly code, but way faster than other\n  // ways I tried that *looked* pretty\n\n  if (descriptor.value) {\n    fn = descriptor.value;\n    wrapKey = 'value';\n  } else if (descriptor.get) {\n    fn = descriptor.get;\n    wrapKey = 'get';\n  } else if (descriptor.set) {\n    fn = descriptor.set;\n    wrapKey = 'set';\n  }\n  return {\n    fn: fn,\n    wrapKey: wrapKey\n  };\n}\nfunction handleDescriptor(target, key, descriptor) {\n  var _metaForDescriptor = metaForDescriptor(descriptor),\n    fn = _metaForDescriptor.fn,\n    wrapKey = _metaForDescriptor.wrapKey;\n  var argumentCache = new WeakMap();\n  var signatureCache = Object.create(null);\n  var primativeRefCache = Object.create(null);\n  var argumentIdCounter = 0;\n  return _extends({}, descriptor, _defineProperty({}, wrapKey, function memoizeWrapper() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var signature = '0';\n    for (var i = 0, l = args.length; i < l; i++) {\n      var arg = args[i];\n      var argRef = toObject(primativeRefCache, arg);\n      var argKey = argumentCache.get(argRef);\n      if (argKey === undefined) {\n        argKey = ++argumentIdCounter;\n        argumentCache.set(argRef, argKey);\n      }\n      signature += argKey;\n    }\n    return signatureCache[signature] || applyAndCache(this, fn, arguments, signatureCache, signature);\n  }));\n}\nexport default function memoize() {\n  internalDeprecation('@memoize is deprecated and will be removed shortly. Use @memoize from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  return decorate(handleDescriptor, args);\n}","map":{"version":3,"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_defineProperty","obj","value","defineProperty","enumerable","configurable","writable","decorate","internalDeprecation","toObject","cache","applyAndCache","context","fn","args","signature","ret","apply","metaForDescriptor","descriptor","wrapKey","get","set","handleDescriptor","_metaForDescriptor","argumentCache","WeakMap","signatureCache","create","primativeRefCache","argumentIdCounter","memoizeWrapper","_len","Array","_key","l","arg","argRef","argKey","undefined","memoize","_len2","_key2"],"sources":["/Users/azminds/Documents/five-g/frontend/node_modules/terminal-in-react-pseudo-file-system-plugin/node_modules/core-decorators/es/memoize.js"],"sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { decorate, internalDeprecation } from './private/utils';\n\nfunction toObject(cache, value) {\n  if (value === Object(value)) {\n    return value;\n  }\n  return cache[value] || (cache[value] = {});\n}\n\nfunction applyAndCache(context, fn, args, cache, signature) {\n  var ret = fn.apply(context, args);\n  cache[signature] = ret;\n  return ret;\n}\n\nfunction metaForDescriptor(descriptor) {\n  var fn = void 0,\n      wrapKey = void 0;\n\n  // This is ugly code, but way faster than other\n  // ways I tried that *looked* pretty\n\n  if (descriptor.value) {\n    fn = descriptor.value;\n    wrapKey = 'value';\n  } else if (descriptor.get) {\n    fn = descriptor.get;\n    wrapKey = 'get';\n  } else if (descriptor.set) {\n    fn = descriptor.set;\n    wrapKey = 'set';\n  }\n\n  return { fn: fn, wrapKey: wrapKey };\n}\n\nfunction handleDescriptor(target, key, descriptor) {\n  var _metaForDescriptor = metaForDescriptor(descriptor),\n      fn = _metaForDescriptor.fn,\n      wrapKey = _metaForDescriptor.wrapKey;\n\n  var argumentCache = new WeakMap();\n  var signatureCache = Object.create(null);\n  var primativeRefCache = Object.create(null);\n  var argumentIdCounter = 0;\n\n  return _extends({}, descriptor, _defineProperty({}, wrapKey, function memoizeWrapper() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var signature = '0';\n\n    for (var i = 0, l = args.length; i < l; i++) {\n      var arg = args[i];\n      var argRef = toObject(primativeRefCache, arg);\n      var argKey = argumentCache.get(argRef);\n\n      if (argKey === undefined) {\n        argKey = ++argumentIdCounter;\n        argumentCache.set(argRef, argKey);\n      }\n\n      signature += argKey;\n    }\n\n    return signatureCache[signature] || applyAndCache(this, fn, arguments, signatureCache, signature);\n  }));\n}\n\nexport default function memoize() {\n  internalDeprecation('@memoize is deprecated and will be removed shortly. Use @memoize from lodash-decorators.\\n\\n  https://www.npmjs.com/package/lodash-decorators');\n\n  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  return decorate(handleDescriptor, args);\n}"],"mappings":"AAAA,IAAIA,QAAQ,GAAGC,MAAM,CAACC,MAAM,IAAI,UAAUC,MAAM,EAAE;EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;IAAE,IAAIG,MAAM,GAAGF,SAAS,CAACD,CAAC,CAAC;IAAE,KAAK,IAAII,GAAG,IAAID,MAAM,EAAE;MAAE,IAAIN,MAAM,CAACQ,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,MAAM,EAAEC,GAAG,CAAC,EAAE;QAAEL,MAAM,CAACK,GAAG,CAAC,GAAGD,MAAM,CAACC,GAAG,CAAC;MAAE;IAAE;EAAE;EAAE,OAAOL,MAAM;AAAE,CAAC;AAEhQ,SAASS,eAAe,CAACC,GAAG,EAAEL,GAAG,EAAEM,KAAK,EAAE;EAAE,IAAIN,GAAG,IAAIK,GAAG,EAAE;IAAEZ,MAAM,CAACc,cAAc,CAACF,GAAG,EAAEL,GAAG,EAAE;MAAEM,KAAK,EAAEA,KAAK;MAAEE,UAAU,EAAE,IAAI;MAAEC,YAAY,EAAE,IAAI;MAAEC,QAAQ,EAAE;IAAK,CAAC,CAAC;EAAE,CAAC,MAAM;IAAEL,GAAG,CAACL,GAAG,CAAC,GAAGM,KAAK;EAAE;EAAE,OAAOD,GAAG;AAAE;AAEhN,SAASM,QAAQ,EAAEC,mBAAmB,QAAQ,iBAAiB;AAE/D,SAASC,QAAQ,CAACC,KAAK,EAAER,KAAK,EAAE;EAC9B,IAAIA,KAAK,KAAKb,MAAM,CAACa,KAAK,CAAC,EAAE;IAC3B,OAAOA,KAAK;EACd;EACA,OAAOQ,KAAK,CAACR,KAAK,CAAC,KAAKQ,KAAK,CAACR,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC;AAC5C;AAEA,SAASS,aAAa,CAACC,OAAO,EAAEC,EAAE,EAAEC,IAAI,EAAEJ,KAAK,EAAEK,SAAS,EAAE;EAC1D,IAAIC,GAAG,GAAGH,EAAE,CAACI,KAAK,CAACL,OAAO,EAAEE,IAAI,CAAC;EACjCJ,KAAK,CAACK,SAAS,CAAC,GAAGC,GAAG;EACtB,OAAOA,GAAG;AACZ;AAEA,SAASE,iBAAiB,CAACC,UAAU,EAAE;EACrC,IAAIN,EAAE,GAAG,KAAK,CAAC;IACXO,OAAO,GAAG,KAAK,CAAC;;EAEpB;EACA;;EAEA,IAAID,UAAU,CAACjB,KAAK,EAAE;IACpBW,EAAE,GAAGM,UAAU,CAACjB,KAAK;IACrBkB,OAAO,GAAG,OAAO;EACnB,CAAC,MAAM,IAAID,UAAU,CAACE,GAAG,EAAE;IACzBR,EAAE,GAAGM,UAAU,CAACE,GAAG;IACnBD,OAAO,GAAG,KAAK;EACjB,CAAC,MAAM,IAAID,UAAU,CAACG,GAAG,EAAE;IACzBT,EAAE,GAAGM,UAAU,CAACG,GAAG;IACnBF,OAAO,GAAG,KAAK;EACjB;EAEA,OAAO;IAAEP,EAAE,EAAEA,EAAE;IAAEO,OAAO,EAAEA;EAAQ,CAAC;AACrC;AAEA,SAASG,gBAAgB,CAAChC,MAAM,EAAEK,GAAG,EAAEuB,UAAU,EAAE;EACjD,IAAIK,kBAAkB,GAAGN,iBAAiB,CAACC,UAAU,CAAC;IAClDN,EAAE,GAAGW,kBAAkB,CAACX,EAAE;IAC1BO,OAAO,GAAGI,kBAAkB,CAACJ,OAAO;EAExC,IAAIK,aAAa,GAAG,IAAIC,OAAO,EAAE;EACjC,IAAIC,cAAc,GAAGtC,MAAM,CAACuC,MAAM,CAAC,IAAI,CAAC;EACxC,IAAIC,iBAAiB,GAAGxC,MAAM,CAACuC,MAAM,CAAC,IAAI,CAAC;EAC3C,IAAIE,iBAAiB,GAAG,CAAC;EAEzB,OAAO1C,QAAQ,CAAC,CAAC,CAAC,EAAE+B,UAAU,EAAEnB,eAAe,CAAC,CAAC,CAAC,EAAEoB,OAAO,EAAE,SAASW,cAAc,GAAG;IACrF,KAAK,IAAIC,IAAI,GAAGvC,SAAS,CAACC,MAAM,EAAEoB,IAAI,GAAGmB,KAAK,CAACD,IAAI,CAAC,EAAEE,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGF,IAAI,EAAEE,IAAI,EAAE,EAAE;MACnFpB,IAAI,CAACoB,IAAI,CAAC,GAAGzC,SAAS,CAACyC,IAAI,CAAC;IAC9B;IAEA,IAAInB,SAAS,GAAG,GAAG;IAEnB,KAAK,IAAIvB,CAAC,GAAG,CAAC,EAAE2C,CAAC,GAAGrB,IAAI,CAACpB,MAAM,EAAEF,CAAC,GAAG2C,CAAC,EAAE3C,CAAC,EAAE,EAAE;MAC3C,IAAI4C,GAAG,GAAGtB,IAAI,CAACtB,CAAC,CAAC;MACjB,IAAI6C,MAAM,GAAG5B,QAAQ,CAACoB,iBAAiB,EAAEO,GAAG,CAAC;MAC7C,IAAIE,MAAM,GAAGb,aAAa,CAACJ,GAAG,CAACgB,MAAM,CAAC;MAEtC,IAAIC,MAAM,KAAKC,SAAS,EAAE;QACxBD,MAAM,GAAG,EAAER,iBAAiB;QAC5BL,aAAa,CAACH,GAAG,CAACe,MAAM,EAAEC,MAAM,CAAC;MACnC;MAEAvB,SAAS,IAAIuB,MAAM;IACrB;IAEA,OAAOX,cAAc,CAACZ,SAAS,CAAC,IAAIJ,aAAa,CAAC,IAAI,EAAEE,EAAE,EAAEpB,SAAS,EAAEkC,cAAc,EAAEZ,SAAS,CAAC;EACnG,CAAC,CAAC,CAAC;AACL;AAEA,eAAe,SAASyB,OAAO,GAAG;EAChChC,mBAAmB,CAAC,+IAA+I,CAAC;EAEpK,KAAK,IAAIiC,KAAK,GAAGhD,SAAS,CAACC,MAAM,EAAEoB,IAAI,GAAGmB,KAAK,CAACQ,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;IACzF5B,IAAI,CAAC4B,KAAK,CAAC,GAAGjD,SAAS,CAACiD,KAAK,CAAC;EAChC;EAEA,OAAOnC,QAAQ,CAACgB,gBAAgB,EAAET,IAAI,CAAC;AACzC"},"metadata":{},"sourceType":"module"}